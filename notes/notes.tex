\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

% quotes
\usepackage{dirtytalk}

% code blocks
\usepackage[outputdir=build, cachedir=build/_minted-notes]{minted}

\title{Problems}
\author{Camilo de Lellis}

\begin{document}
\maketitle

\tableofcontents

% -----|-----|-----|-----|-----

\section{Leetcode Two Sum}

% Problem Info
\textbf{Platform:} Leetcode \\
\textbf{Difficulty:} Easy \\
\textbf{Tags:} Array, Hash Table

% Problem Description
Given an array of integers \texttt{nums} and an integer \texttt{target}, return indices of the two numbers such that they add up to \texttt{target}. 

You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

% Examples
\textbf{Example 1:} \\
Input: nums = [2,7,11,15], target = 9 \\
Output: [0,1] \\
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

\textbf{Example 2:} \\
Input: nums = [3,2,4], target = 6 \\
Output: [1,2]

\textbf{Example 3:} \\
Input: nums = [3,3], target = 6 \\
Output: [0,1]

% Constraints
\begin{itemize}
    \item $2 \leq \text{nums.length} \leq 10^4$
    \item $-10^9 \leq \text{nums[i]} \leq 10^9$
    \item $-10^9 \leq \text{target} \leq 10^9$
    \item Only one valid answer exists
\end{itemize}

% Follow-up
\textbf{Follow-up:} Can you come up with an algorithm that is less than $O(n^2)$ time complexity?

% C implementation
\begin{minted}{c}
#include <stdio.h>
#include <stdlib.h>

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    for (int i = 0; i < numsSize; i++){
        for (int j = i + 1; j < numsSize; j++){
            if(nums[i] + nums[j] == target){
                int* result = (int*)malloc(2*sizeof(int));
                *returnSize = 2;
                result[0] = i;
                result[1] = j;
                return result;
            }
        }
    }
    *returnSize = 0;
    return NULL;
}
\end{minted}

% Complexity Analysis
\textbf{Time Complexity:} $O(n^2)$ — nested loops iterate over all pairs. \\
\textbf{Space Complexity:} $O(1)$ — only constant extra space used (ignoring output array).

% Lessons Learned
\begin{itemize}
    \item Brute-force works for small arrays, but follow-up requires using a hash map for $O(n)$ solution.
    \item Always read constraints carefully — input size determines whether $O(n^2)$ is feasible.
    \item Separating approach, code, and lessons makes reviewing problems much faster.
\end{itemize}

% -----|-----|-----|-----|-----

\bibliographystyle{plain}
\bibliography{references}

\end{document}
